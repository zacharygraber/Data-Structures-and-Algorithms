//-----------------------------------------------------------------------
// Empty AVL exception

class EmptyAVLE extends Exception {
}

//-----------------------------------------------------------------------
// Abstract AVL class

abstract class AVL<E extends Comparable<E>> implements TreePrinter.PrintableNode {

    //--------------------------
    // Static fields and methods
    //--------------------------

    static EmptyAVLE EAVLX = new EmptyAVLE();

    //--------------------------
    // Getters and simple methods
    //--------------------------

    abstract E AVLData() throws EmptyAVLE;

    abstract AVL<E> AVLLeft() throws EmptyAVLE;

    abstract AVL<E> AVLRight() throws EmptyAVLE;

    abstract boolean isEmpty();

    abstract int AVLHeight();

    //--------------------------
    // Main methods
    //--------------------------

    abstract boolean AVLfind(E key);

    abstract AVL<E> AVLinsert(E key);

    abstract AVL<E> AVLeasyRight();

    abstract AVL<E> AVLrotateRight();

    abstract AVL<E> AVLeasyLeft();

    abstract AVL<E> AVLrotateLeft();

    /**
     * Four new methods to convert an AVL tree to a red-black one. The
     * main idea of the algorithm we will use can be captured by the
     * following invariants:
     *
     * An AVL tree of height 2n can be converted to a red tree
     *   with black height n. This is what method colorRed() should do.
     *
     * An AVL tree of height 2n can be converted to a black tree
     *   with black height (n+1). This is what method colorBlackEven
     *   should do.
     *
     * An AVL tree of height 2n+1 can be converted to a black tree
     *   with black height (n+1). This is what method colorBlackOdd
     *   should do.
     *
     * The entry point for these methods is the method toRB(). Simce
     * the root should be colored black, it calls colorBlackEven or
     * colorBlackOdd depending on whether the current AVL tree has
     * even height or odd height.
     *
     */

    abstract RedBlackT<E> toRB ();

    /**
     * When this method is called, it creates a black node whose
     * colors are calculated as follows:
     *   - if the current AVL tree has children of equal height,
     *     then the generated nodes are red
     *   - if the current AVL tree has children that differ in
     *     height, then the generated node for the shorter tree
     *     is black and the other is red
     */
    abstract RedBlackT<E> colorBlackOdd ();

    /**
     * When this method is called, it creates a black node whose children
     * will also be black. The children are generated by either colorBlackEven
     * or colorBlackOdd depending on whether the height of the AVL child
     * is even or odd.
     */
    abstract RedBlackT<E> colorBlackEven ();

    /**
     * When this method is called, it creates a red node whose children
     * must be black. The children are generated by either colorBlackEven
     * or colorBlackOdd depending on whether the height of the AVL child
     * is even or odd.
     */
    abstract RedBlackT<E> colorRed  ();
}

//-----------------------------------------------------------------------

class EmptyAVL<E extends Comparable<E>> extends AVL<E> {

    //--------------------------
    // Getters and simple methods
    //--------------------------

    E AVLData() throws EmptyAVLE {
        throw EAVLX;
    }

    AVL<E> AVLLeft() throws EmptyAVLE {
        throw EAVLX;
    }

    AVL<E> AVLRight() throws EmptyAVLE {
        throw EAVLX;
    }

    boolean isEmpty() {
        return true;
    }

    // We are changing our convention for the height of an empty tree
    // This will make it easier to state the invariant needed to
    // convert to a red-black tree
    int AVLHeight() {
        return 1;
    }

    //--------------------------
    // Main methods
    // Adapting the methods from before to this generic class
    //--------------------------

    boolean AVLfind(E key) {
        return false;
    }

    AVL<E> AVLinsert(E key) {
        return new AVLNode<>(key, new EmptyAVL<>(), new EmptyAVL<>());
    }

    AVL<E> AVLeasyRight() {
        throw new Error("Internal bug: should never call easyRight on empty tree");
    }

    AVL<E> AVLrotateRight() {
        throw new Error("Internal bug: should never call rotateRight on empty tree");
    }

    AVL<E> AVLeasyLeft() {
        throw new Error("Internal bug: should never call easyLeft on empty tree");
    }

    AVL<E> AVLrotateLeft() {
        throw new Error("Internal bug: should never call rotateLeft on empty tree");
    }

    RedBlackT<E> toRB () {
        return null; // TODO
    }

    RedBlackT<E> colorBlackEven () {
        return null; // TODO
    }

    RedBlackT<E> colorBlackOdd () {
        return null; // TODO
    }

    RedBlackT<E> colorRed  () {
        return null; // TODO
    }

    //--------------------------
    // Override
    //--------------------------

    public boolean equals(Object o) {
        return (o instanceof EmptyAVL);
    }

    //--------------------------
    // Printable interface
    //--------------------------

    public TreePrinter.PrintableNode getLeft() {
        return null;
    }

    public TreePrinter.PrintableNode getRight() {
        return null;
    }

    public String getText() {
        return "";
    }
}

//-----------------------------------------------------------------------

class AVLNode<E extends Comparable<E>> extends AVL<E> {
    private final E data;
    private final AVL<E> left;
    private final AVL<E> right;
    private final int height;

    AVLNode(E data, AVL<E> left, AVL<E> right) {
        this.data = data;
        this.left = left;
        this.right = right;
        this.height = 1 + Math.max(left.AVLHeight(), right.AVLHeight());
    }

    //--------------------------
    // Getters and simple methods
    //--------------------------

    E AVLData() {
        return data;
    }

    AVL<E> AVLLeft() {
        return left;
    }

    AVL<E> AVLRight() {
        return right;
    }

    boolean isEmpty() {
        return false;
    }

    int AVLHeight() {
        return height;
    }

    //--------------------------
    // Main methods
    // Adapt methods from before to this generic class
    //--------------------------

    boolean AVLfind(E key) {
        return false; // TODO
    }

    AVL<E> AVLinsert(E key) {
        return null; // TODO
    }

    AVL<E> AVLeasyRight() {
        return null; // TODO
    }

    AVL<E> AVLrotateRight() {
        return null; // TODO
    }

    AVL<E> AVLeasyLeft() {
        return null; // TODO
    }

    AVL<E> AVLrotateLeft() {
        return null; // TODO
    }

    RedBlackT<E> toRB () {
        return null; // TODO
    }

    RedBlackT<E> colorBlackEven () {
        return null; // TODO
    }

    RedBlackT<E> colorBlackOdd () {
        return null; // TODO
    }

    RedBlackT<E> colorRed  () {
        return null; // TODO
    }

    //--------------------------
    // Override
    //--------------------------

    public boolean equals(Object o) {
        if (o instanceof AVLNode) {
            AVLNode other = (AVLNode) o;
            return data == other.data && left.equals(other.left) && right.equals(other.right);
        }
        return false;
    }

    //--------------------------
    // Printable interface
    //--------------------------

    public TreePrinter.PrintableNode getLeft() {
        return left.isEmpty() ? null : left;
    }

    public TreePrinter.PrintableNode getRight() {
        return right.isEmpty() ? null : right;
    }

    public String getText() {
        return String.valueOf(data);
    }
}

//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
